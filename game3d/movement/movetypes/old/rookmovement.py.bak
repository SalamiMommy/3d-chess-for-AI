# game3d/movement/movetypes/rookmovement.py

"""3D Rook move generation logic — pure movement rules, no registration."""

from typing import List
from game3d.pieces.enums import PieceType
from game3d.game.gamestate import GameState
from game3d.movement.pathvalidation import slide_along_directions, validate_piece_at
from game3d.movement.movepiece import Move
# Define rook directions — could also go in directions.py later
ROOK_DIRECTIONS_3D = [
    (1, 0, 0), (-1, 0, 0),  # X axis
    (0, 1, 0), (0, -1, 0),  # Y axis
    (0, 0, 1), (0, 0, -1)   # Z axis
]


def generate_rook_moves(state: GameState, x: int, y: int, z: int) -> List[Move]:
    """
    Generate all legal rook moves from (x, y, z).
    Uses centralized sliding logic from pathvalidation.py.
    Returns empty list if no valid rook is at start position.
    """
    pos = (x, y, z)

    # Validate piece exists and is correct type/color
    if not validate_piece_at(state, pos, PieceType.ROOK):
        return []

    # Delegate to shared sliding logic
    return slide_along_directions(
        state,
        start=pos,
        directions=ROOK_DIRECTIONS_3D,
        allow_capture=True,      # Rooks can capture
        allow_self_block=False   # Rooks cannot move through or onto friendly pieces
    )
