"""
Fused Filtering Kernels for Move Generation.
"""
import numpy as np
from numba import njit, prange
from game3d.common.shared_types import (
    COORD_DTYPE, BOOL_DTYPE, SIZE, Color, PieceType
)
from game3d.core.buffer import GameBuffer

@njit(cache=True, nogil=True, parallel=True)
def _filter_batch_kernel(
    moves: np.ndarray,
    board_type: np.ndarray,      # (SIZE, SIZE, SIZE) piece types
    board_color: np.ndarray,     # (SIZE, SIZE, SIZE) piece colors
    is_frozen: np.ndarray,       # (SIZE, SIZE, SIZE) boolean map
    player_color: int,
    check_swapper: bool,
    check_wall: bool
) -> np.ndarray:
    """
    Fused kernel for filtering moves based on static rules:
    1. Frozen Status
    2. Wall Constraints (Captures & Edge Bounds)
    3. Swapper Constraints (Swapper swapping with Wall)
    
    Args:
        moves: (N, 6) array [fx, fy, fz, tx, ty, tz]
        board_type: Piece types grid
        board_color: Piece colors grid
        is_frozen: Frozen status grid
        player_color: Current player's color
        check_swapper: Whether to apply Swapper rules
        check_wall: Whether to apply Wall rules
        
    Returns:
        Boolean mask (N,) where True means keep the move.
    """
    n = moves.shape[0]
    keep_mask = np.ones(n, dtype=BOOL_DTYPE)
    
    # Pre-compute constants
    WALL_TYPE = PieceType.WALL
    SWAPPER_TYPE = PieceType.SWAPPER
    
    for i in prange(n):
        fx, fy, fz = moves[i, 0], moves[i, 1], moves[i, 2]
        tx, ty, tz = moves[i, 3], moves[i, 4], moves[i, 5]
        
        # 1. Filter: Frozen Pieces
        # If source is frozen, move is invalid
        if is_frozen[fx, fy, fz]:
            keep_mask[i] = False
            continue
            
        # Helper: Get piece types (avoid bounds check since moves are generated valid)
        # Note: moves generated by pseudolegal generator are within bounds
        # BUT we should be safe.
        
        source_type = board_type[fx, fy, fz]
        dest_type = board_type[tx, ty, tz]
        dest_color = board_color[tx, ty, tz]
        
        # 2. Filter: Wall Logic
        if check_wall:
            # A. Wall Edge Bounds (Wall cannot move to edge)
            if source_type == WALL_TYPE:
                if tx >= SIZE - 1 or ty >= SIZE - 1:
                    keep_mask[i] = False
                    continue
            
            # B. Wall Capture Restrictions
            # If destination is a Wall, check capture rules
            if dest_type == WALL_TYPE:
                # Capture rules depend on attacker's Z relative to Wall's Z
                # White Wall: Attacker must be Z <= Wall Z (from below/same) for valid capture?
                # Actually, logic from generator.py was:
                # Invalid if:
                # (White Wall AND Attacker Z > Wall Z) OR (Black Wall AND Attacker Z < Wall Z)
                
                is_white_wall = (dest_color == Color.WHITE)
                is_black_wall = (dest_color == Color.BLACK)
                
                # Logic:
                # If White Wall, attacker must NOT be above (fz > tz) -> Invalid
                # If Black Wall, attacker must NOT be below (fz < tz) -> Invalid
                
                if is_white_wall:
                    if fz > tz:
                        keep_mask[i] = False
                        continue
                elif is_black_wall:
                    if fz < tz:
                        keep_mask[i] = False
                        continue
        
        # 3. Filter: Swapper-Wall Swap Prevention
        if check_swapper:
            if source_type == SWAPPER_TYPE:
                if dest_type == WALL_TYPE:
                    # Swapper cannot swap with Wall (would corrupt structure)
                    keep_mask[i] = False
                    continue
                    
    return keep_mask
